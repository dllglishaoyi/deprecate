<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.3.1 by Michael Rose
  Copyright 2017 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin SEO -->









<title>第三章: 函数 vs. 块级作用域 - Laolizi’s Blog</title>




<meta name="description" content="你不知道的JS:作用域和闭包第三章: 函数 vs. 块级作用域">




<meta name="author" content="Laolizi">

<meta property="og:locale" content="en">
<meta property="og:site_name" content="Laolizi's Blog">
<meta property="og:title" content="第三章: 函数 vs. 块级作用域">




  <meta property="og:description" content="你不知道的JS:作用域和闭包第三章: 函数 vs. 块级作用域">





  

  





  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2016-03-16T00:00:00+08:00">








  <script type="application/ld+json">
    {
      "@context" : "http://schema.org",
      "@type" : "Person",
      "name" : "Laolizi",
      "url" : null,
      "sameAs" : null
    }
  </script>






<!-- end SEO -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Laolizi's Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->

<meta http-equiv="cleartype" content="on">
    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->
  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Laolizi's Blog</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item"><a href="https://github.com/dllglishaoyi">About</a></li>
          
        </ul>
        <button><div class="navicon"></div></button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    



<div id="main" role="main">
  
  <div class="sidebar sticky">
  

<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/avatar.jpeg" class="author__avatar" alt="Laolizi" itemprop="image">
      
    </div>
  

  <div class="author__content">
    <h3 class="author__name" itemprop="name">Laolizi</h3>
    
      <p class="author__bio" itemprop="description">
        老李子果果
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> <span itemprop="name">Being,China</span>
        </li>
      

      

      
        <li>
          <a href="mailto:dllglishaoi@gmail.com">
            <meta itemprop="email" content="dllglishaoi@gmail.com" />
            <i class="fa fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/laolizi" itemprop="sameAs">
            <i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      

      

      

      

      

      
        <li>
          <a href="https://github.com/dllglishaoyi" itemprop="sameAs">
            <i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fa fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="第三章: 函数 vs. 块级作用域">
    <meta itemprop="description" content="你不知道的JS:作用域和闭包第三章: 函数 vs. 块级作用域">
    <meta itemprop="datePublished" content="March 16, 2016">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 class="page__title" itemprop="headline">第三章: 函数 vs. 块级作用域
</h1>
          
            <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  4 minute read
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        <h1 id="你不知道的js作用域和闭包">你不知道的JS:作用域和闭包</h1>
<h1 id="第三章-函数-vs-块级作用域">第三章: 函数 vs. 块级作用域</h1>

<p>我们在第二章探索过，作用域由一系列“泡泡”组成，这些“泡泡”就像装着标识符（变量、方法）的桶。这些“泡泡”整齐地嵌套，并且这些嵌套在写代码时就定义好了。</p>

<p>但到底是什么构造了一个新的泡泡？只能是函数吗？JavaScript中还有别的什么结构能创造作用域泡泡呢？</p>

<h2 id="函数作用域">函数作用域</h2>

<p>对于这些问题，最普通的答案莫过于JavaScript拥有基于函数的作用域了。就是说，你声明的每个函数都为它自己创造了一个泡泡，但没别的结构能为自己创建泡泡了。我们来看看为什么这么说，尽管这不是特别准确。</p>

<p>首先，我们来看看函数作用域和它的实现。</p>

<p>有如下代码：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="c1">// some code</span>

	<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ...</span>
	<span class="p">}</span>

	<span class="c1">// more code</span>

	<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>在这段代码当中，<code class="highlighter-rouge">foo(..)</code>的作用域泡泡包含了标识符<code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c</code> 和 <code class="highlighter-rouge">bar</code>。不论在作用域的那个地方声明变量，变量和方法都属于这个作用域泡泡。这一点我们会在下一章具体讨论。</p>

<p><code class="highlighter-rouge">bar(..)</code>拥有它自己的作用域泡泡。全局作用域也有一个属于自己的泡泡，它只包含一个名叫<code class="highlighter-rouge">foo</code>的标识符。</p>

<p>因为<code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c</code>, 和 <code class="highlighter-rouge">bar</code>都属于<code class="highlighter-rouge">foo(..)</code>的作用域泡泡，他们是无法从<code class="highlighter-rouge">foo(..)</code>外面访问的。也就是说，以下的代码会引起<code class="highlighter-rouge">ReferenceError</code>报错，因为这些标识符是无法从全局作用域访问的：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">bar</span><span class="p">();</span> <span class="c1">// 失败</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="p">);</span> <span class="c1">// 三个都失败</span>
</code></pre>
</div>

<p>然而, 所有的这些标识符 (<code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c</code>, <code class="highlighter-rouge">foo</code>, 和 <code class="highlighter-rouge">bar</code>)是可以从<code class="highlighter-rouge">foo(..)</code>的 <em>外部</em>访问的, 而且 <code class="highlighter-rouge">bar(..)</code>内部也可以访问 (假设<code class="highlighter-rouge">bar(..)</code>内没有声明覆盖他们).</p>

<p>函数作用域鼓励一直思想：所有变量属于函数，函数内部（甚至在内部的嵌套作用域中）处处可以访问他们。这种设计方式是非常有用的，它可以把JavaScript按需处理不同类型值得动态特性发挥到极致。</p>

<p>另一方面，如果你疏于防范，存在于整个作用域中的变量会产生一些意想不到的隐患。</p>

<h2 id="藏在作用域中">藏在作用域中</h2>

<p>通常对函数的想法就是声明一个函数，然后再在其中加入代码。其实反过来也同样强大和有用：选择一段你写过的代码，然后用一个函数声明把它包裹起来，这样就“隐藏”了这段代码。</p>

<p>这样实际上是创造了一个环绕代码的作用域泡泡，也就是说，任何代码中的声明（变量和方法）现在都会被新的函数作用域包裹起来。换句话说，你可以通过用函数作用域包裹的方法吧变量“隐藏”起来。</p>

<p>为什么说“隐藏”变量和函数是一种有用的技术呢？</p>

<p>有几个原因。它们遵循了软件设计原则中的“最小权限原则”。在软件设计中，例如一个对象的API，这个原则表现为向外暴露最少量的东西以满足需求，然后隐藏其他所有的东西。</p>

<p>这个原则扩展了用哪个作用域来包含变量和函数。如果所有的变量和函数都在全局作用域中，它们当然可以被所有的嵌套作用域访问。但这违背了“最小…”原则。这暴露了很多本该私有化的变量和方法，这种完全的用法会让变量/方法的访问变得不美。</p>

<p>例如:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">doSomethingElse</span><span class="p">(</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>

	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">b</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">doSomething</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// 15</span>
</code></pre>
</div>
<p>在这段代码中 <code class="highlighter-rouge">b</code> 变量和 <code class="highlighter-rouge">doSomethingElse(..)</code> 方法从他们所做的事来看应该是“私有的”。把他们的入口暴露在外不但是不必要的，而且可能会是“危险”的，他们可能被一些不希望的方式有意无意地调用， 而且还可能打乱<code class="highlighter-rouge">doSomething(..)</code>执行的前提条件。</p>

<p>把这些私密的细节隐藏在<code class="highlighter-rouge">doSomething(..)</code>的作用域中，将会是个更恰当的设计：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">function</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">b</span><span class="p">;</span>

	<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">doSomethingElse</span><span class="p">(</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>

	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nx">doSomething</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// 15</span>
</code></pre>
</div>
<p>现在，<code class="highlighter-rouge">b</code> 和 <code class="highlighter-rouge">doSomethingElse(..)</code> 无法从外部访问了,取而代之的是只能对 <code class="highlighter-rouge">doSomething(..)</code>的控制。这样做对功能性和结果并没有什么影响，但这种设计把细节私有化，这是一种更好的软件实践。</p>

<h3 id="冲突避免">冲突避免</h3>

<p>隐藏变量和方法的另一个好处就是可以避免两个同名标识符的冲突。这种冲突常常是因为意外覆盖了值引起的。</p>

<p>例如：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 改变了for循环中 `i` 的值</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">i</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">bar</span><span class="p">(</span> <span class="nx">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// oops, 死循环!</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
</code></pre>
</div>
<p>在 <code class="highlighter-rouge">bar(..)</code>中<code class="highlighter-rouge">i = 3</code>的赋值意外覆盖了<code class="highlighter-rouge">foo(..)</code>中for循环里声明的<code class="highlighter-rouge">i</code>。此时，引发了一个死循环，因为<code class="highlighter-rouge">i</code>被赋予了一个固定值 <code class="highlighter-rouge">3</code> ，永远小于10。</p>

<p><code class="highlighter-rouge">bar(..)</code>里的赋值需要声明一个本地变量，无所谓标识符叫什么名字。 <code class="highlighter-rouge">var i = 3;</code>能解决这个问题（会为<code class="highlighter-rouge">i</code>创建一个我们前面提到的“阴影变量”声明）。</p>

<h4 id="全局命名空间">全局命名空间</h4>

<p>在你程序中引入的多个类库如果不完全隐藏它们的内部/私有的方法和变量，和容易引起冲突。</p>

<p>这些类库通常会创建一个单独的变量声明，经常是一个在全局作用域中拥有唯一名字的对象。这个对象会运用是一个属于这个类库自己的“命名空间”，所有对外暴露的函数都表现为对象（命名空间）的属性，而不是顶层作用域中的标识符。</p>

<p>例如:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">MyReallyCoolLibrary</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">awesome</span><span class="p">:</span> <span class="s2">"stuff"</span><span class="p">,</span>
	<span class="na">doSomething</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ...</span>
	<span class="p">},</span>
	<span class="na">doAnotherThing</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ...</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h4 id="模块管理">模块管理</h4>

<p>另一种避免冲突的方法就是模块化，运用一些依赖管理器。通过运用这些工具，就再也不会有类库向全局作用域添加标识符了，但需要通过依赖管理器提供的机制指定引入标识符到具体的作用域中。</p>

<p>你可能会注意到这些工具并没有什么可以摆脱词法作用域规则的魔法。它们只是运用了作用域规则来强制了标识符不能出现在共享的作用域中，保持标识符私有化，杜绝冲突污染的作用域，以此确保没有意外的作用域冲突。</p>

<p>因此，你自己也可以写出像模块管理器一样的代码，如果你要这么做。在第五章的模块模式中会有更多信息。</p>

<h2 id="作用域函数">作用域函数</h2>

<p>我们已经知道可以通过用函数包裹代码的方式有效地隐藏变量和方法。</p>

<p>例如:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// &lt;-- insert this</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>

<span class="p">}</span> <span class="c1">// &lt;-- and this</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// &lt;-- and this</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre>
</div>
<p>虽然这在技术上可行，但却不是一个好主意。这里有一些小问题。首先我们要声明一个名叫<code class="highlighter-rouge">foo()</code>的方法，这意味着叫做 <code class="highlighter-rouge">foo</code> 的标识符污染了它自己的作用域（这个例子中是全局作用域）。而且我们要明确地通过名字（<code class="highlighter-rouge">foo()</code>）来调用这个方法。</p>

<p>试想一下如果这个方法不需要名字（或者名字不会污染作用域），而且它可以自动执行的话会怎么样呢。</p>

<p>幸运的是，JavaScript为这个问题提供了解决方案。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="c1">// &lt;-- insert this</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>

<span class="p">})();</span> <span class="c1">// &lt;-- and this</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre>
</div>

<p>让我们看看这都发生了什么。</p>

<p>首先，要注意的是包装函数表达式是以 <code class="highlighter-rouge">(function...</code>开始的而不是 <code class="highlighter-rouge">function...</code>。这个看似微小的细节，实际上有很大的不同。相较于标准的函数声明，这个函数被当做一个函数表达式来对待。</p>

<p><strong>注释:</strong>一个区别声明和表达式的最简单方法就是”function”单词在语句中的位置。如果”function”在语句最前端，那他就是函数声明。不然就是一个函数表达式。</p>

<p>我们可以发现函数声明和函数表达式的主要不同在于他们的名字在何处绑定为标识符。</p>

<p>对比前面的两段代码。第一段中的<code class="highlighter-rouge">foo</code>在环绕作用域中绑定。第二段中，<code class="highlighter-rouge">foo</code>不在环绕作用域中绑定，而是在他自己内部的方法中绑定。</p>

<p>换句话说，<code class="highlighter-rouge">(function foo(){ .. })</code> 是一个表达式意味着<code class="highlighter-rouge">foo</code>标识符 <em>只能</em>在<code class="highlighter-rouge">..</code>的内部被找到，而不能在外部作用域中找到。</p>

<p>In other words, <code class="highlighter-rouge">(function foo(){ .. })</code> as an expression means the identifier <code class="highlighter-rouge">foo</code> is found <em>only</em> in the scope where the <code class="highlighter-rouge">..</code>。 把<code class="highlighter-rouge">foo</code>的名字隐藏在它自己内部意味着它不会无故的污染环绕作用域。</p>

<h3 id="匿名-vs-声明的">匿名 vs. 声明的</h3>

<p>你可能最熟悉把函数表达式作为一个回调参数了吧，就像：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"I waited 1 second!"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span> <span class="p">);</span>
</code></pre>
</div>

<p>这被叫做“匿名函数表达式”，因为 <code class="highlighter-rouge">function()...</code>没有他自己的标识符。函数表达式可以是匿名的，但方法声明不能漏掉名字，因为那样会引起JS语法错误。</p>

<p>匿名函数表达式很简单，很多类库和工具都鼓励使用这种惯用的编码风格。
尽管它们需要考虑几个问题：</p>

<ol>
  <li>
    <p>匿名函数没有在追踪栈里留下有用的名字，这增大了调试难度。</p>
  </li>
  <li>
    <p>没有名字的情况下，当函数需要引用自己（诸如递归）时，就要不幸的用到<code class="highlighter-rouge">arguments.callee</code>这种已经<strong>不推荐</strong>的引用了。另一个函数需要自我引用的例子就是一个事件处理函数需要在触发之后解除绑定。</p>
  </li>
  <li>
    <p>匿名函数删掉了有利于代码可读性的名字。</p>
  </li>
</ol>

<p><strong>行内函数表达式</strong>是强大和有用的————但依然也引出很多问题，为你的函数表达式起个名字就能很好的解决。所以始终给你的函数表达式命名是一个最佳的实践：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span> <span class="nx">timeoutHandler</span><span class="p">(){</span> <span class="c1">// &lt;-- 瞧，我有一个名字!</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="s2">"I waited 1 second!"</span> <span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span> <span class="p">);</span>
</code></pre>
</div>

<h3 id="立即执行函数表达式">立即执行函数表达式</h3>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>

<span class="p">})();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre>
</div>

<p>现在我们为函数加上一对括号使之成为函数表达式，我们可以通过在它后面在加上<code class="highlighter-rouge">()</code> 使函数执行，就像<code class="highlighter-rouge">(function foo(){ .. })()</code>。第一对括号生成一个函数表达式，第二对括号使函数执行。</p>

<p>只是一个很普通的模式，几年前在业界就为此有了一个术语：<strong>IIFE</strong>，代表了<strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong>xpression（立即执行函数表达式）。</p>

<p>当然，IIFE不一定需要名字，IIFE的通常格式就是用一个匿名函数表达式。虽然不是通常用法，但为IIFE命名也拥有上面所有匿名函数表达式的好处，所以不失为一个好的选择实践。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">IIFE</span><span class="p">(){</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>

<span class="p">})();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre>
</div>
<p>这与通常的IIFE格式（<code class="highlighter-rouge">(function(){ .. }())</code>）相比有一些小差异。仔细看看有什么不同。第一个格式中，函数表达式被包裹在 <code class="highlighter-rouge">( )</code>中，然后执行括号对在它的外面。第二个格式中，执行括号对被移动到了包裹括号对里面。</p>

<p>这两种格式在功能上都是相同的。<strong>用哪一种完全出于你的格式喜好。</strong></p>

<p>IIFE另一个在实际中更常用的方式就是调用函数，并给他传入参数。</p>

<p>例如:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">IIFE</span><span class="p">(</span> <span class="nx">global</span> <span class="p">){</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">global</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>

<span class="p">})(</span> <span class="nb">window</span> <span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre>
</div>

<p>我们传入了<code class="highlighter-rouge">window</code>对象的引用，但我们给参数命名为<code class="highlighter-rouge">global</code>，从而在文法上相较于非全局引用更清晰，你可以传入在包裹作用域的任何东西，然后为参数来一个恰当的命名。这更是一种文法风格的选择。</p>

<p>这个模式的另一个应用就是防止因<code class="highlighter-rouge">undefined</code>标识符被不正确的重写而引起的意外结果。通过把参数命名为<code class="highlighter-rouge">undefined</code>而不传入参数，我们就能确保<code class="highlighter-rouge">undefined</code>标识符确实是undefined的值：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kc">undefined</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// setting a land-mine for other code! avoid!</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">IIFE</span><span class="p">(</span> <span class="kc">undefined</span> <span class="p">){</span>

	<span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="s2">"Undefined is safe here!"</span> <span class="p">);</span>
	<span class="p">}</span>

<span class="p">})();</span>
</code></pre>
</div>
<p>还有一种用法就是把函数作为参数传入。这种模式被应用在UMD（Universal Module Definition）项目中。有的人会觉得这样做更清晰和利用理解，尽管它有一些冗长：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">IIFE</span><span class="p">(</span> <span class="nx">def</span> <span class="p">){</span>
	<span class="nx">def</span><span class="p">(</span> <span class="nb">window</span> <span class="p">);</span>
<span class="p">})(</span><span class="kd">function</span> <span class="nx">def</span><span class="p">(</span> <span class="nx">global</span> <span class="p">){</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">global</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>

<span class="p">});</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">def</code>函数表达式在代码段的后半部分，被作为一个参数传入定义在代码段前半部分的<code class="highlighter-rouge">IIFE</code>函数。最后，参数<code class="highlighter-rouge">def</code>（函数）被执行，带着传入的参数<code class="highlighter-rouge">global</code>（<code class="highlighter-rouge">window</code>）。</p>

<h2 id="块级作用域">块级作用域</h2>

<p>函数是最普通的作用域单元，当然，在广泛传播的JS设计方法中，还有别的作用域单元，运用这些作用域单元，可以让代码变得更加清晰可维护。</p>

<p>很多JavaScript之外的语言都支持块级作用域，所以其他语言的开发者们对这个概念就有思维定势，而以JavaScript为主的开发者对这个概念可能会有点陌生。</p>

<p>但就算你一次也没写过块级作用域，你对JavaScript这段代码也肯定很熟悉。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">i</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>我们直接在循环的开头声明了变量 <code class="highlighter-rouge">i</code>，我们很可能只希望在这个循环中使用 <code class="highlighter-rouge">i</code>，但忽略了这个变量存在于包裹作用域（函数或全局对象）中。</p>

<p>这就是块级作用域。尽量在使用时就近声明变量。
另一个例子:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="nx">bar</span> <span class="o">=</span> <span class="nx">something</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>我们只在if代码中用到了变量<code class="highlighter-rouge">bar</code>，这让人意识到我们应该在if块中声明<code class="highlighter-rouge">bar</code>。尽管我们在哪用 <code class="highlighter-rouge">var</code>来声明变量都没关系，因为他们都属于包裹作用域。这段代码实际上是一个“假的”块级作用域，应该自我强制不要在作用域的其他地方用到<code class="highlighter-rouge">bar</code>。</p>

<p>块级作用域是一个扩展前面提到“最小权限暴露原则”的工具，通过把在函数中隐藏信息变为在代码块中隐藏信息。</p>

<p>再看看前面的循环例子：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">i</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>为什么只在循环中使用的变量<code class="highlighter-rouge">i</code>会污染整个函数作用域？</p>

<p>但更重要的是，开发者们喜欢靠自己检查来排查不在他们意图范围内的变量使用，例如在一个错误的地方使用一个未知的变量会抛出一个错误。块级作用域（如果有的话）可以让变量 <code class="highlighter-rouge">i</code>只在循环内有效，在函数的其他地方使用 <code class="highlighter-rouge">i</code>会引发错误。这样能确保变量不在其他不好排查的地方重复使用。</p>

<p>但是，令人伤心的事实是，表面上，JavaScript没有块级作用域场景。</p>

<p>除非，你更深入一点。</p>

<h3 id="with"><code class="highlighter-rouge">with</code></h3>

<p>我们在第二章学过<code class="highlighter-rouge">with</code>。尽管它是个令人皱眉的结构，但它确实是一个块级作用域的例子，作用域在<code class="highlighter-rouge">with</code>块中，而不在包裹作用域中。</p>

<h3 id="trycatch"><code class="highlighter-rouge">try/catch</code></h3>

<p>这是个鲜为人知的事实，在ES3版本的JavaScript中的<code class="highlighter-rouge">try/catch</code>，<code class="highlighter-rouge">catch</code>块是一个块级作用域。</p>

<p>例如:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
	<span class="kc">undefined</span><span class="p">();</span> <span class="c1">// 强制引起异常的非法操作!</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">err</span> <span class="p">);</span> <span class="c1">// 起作用了!</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">err</span> <span class="p">);</span> <span class="c1">// ReferenceError: `err` not found</span>
</code></pre>
</div>

<p>如你所见， <code class="highlighter-rouge">err</code>只存在 <code class="highlighter-rouge">catch</code>分句子中，当你在别处引用它时会抛出异常。</p>

<h3 id="let"><code class="highlighter-rouge">let</code></h3>
<p>目前为止，我们在探索块级作用域的过程中看到了很多怪异的行为。如果只是这些的话，块级作用域对JavaScript开发者就没什么大用了。</p>

<p>幸运的是，ES6改变了这一切，它引入了<code class="highlighter-rouge">let</code>关键字，是<code class="highlighter-rouge">var</code>之外的另一种声明变量的方式。</p>

<p><code class="highlighter-rouge">let</code>关键字声明的变量是块级作用域有效的。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="nx">bar</span> <span class="o">=</span> <span class="nx">something</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span> <span class="c1">// ReferenceError</span>
</code></pre>
</div>
<p>用<code class="highlighter-rouge">let</code>来使变量依附块级作用域多少有些含蓄。当你没有太在意变量属于哪个作用域是可能会引起困惑，用新的块把它们包裹起来是一个进化你新代码的好习惯。</p>

<p>为块级作用域创建明确的块可以打消这些担忧:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">{</span> <span class="c1">// &lt;-- explicit block</span>
		<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="nx">bar</span> <span class="o">=</span> <span class="nx">something</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span> <span class="c1">// ReferenceError</span>
</code></pre>
</div>
<p>我们只需简单创建一对大括号来绑定<code class="highlighter-rouge">let</code>并且这是语法可行的。在这个例子中，我们在if分句中创造了一个明确的块，这样做既简单有不会影响if分句的语义。</p>

<p><strong>注释:</strong> 另一种指定块级作用域的方法，见附录B。</p>

<p>在第四章中，我们要讨论提升，在声明所处的作用域中，处处可以得到它。</p>

<p>但是，用<code class="highlighter-rouge">let</code>的声明不会提升到整个块中。这种声明直到执行到声明语句时才会被认为是存在的。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span> <span class="p">);</span> <span class="c1">// ReferenceError!</span>
   <span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="垃圾回收">垃圾回收</h4>

<p>块级作用域有用的另一个原因是对于闭包和垃圾回收的。我们只在这里简要提及，闭包机制我们会在第五章详细介绍。</p>

<p>且看:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do something interesting</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">someReallyBigData</span> <span class="o">=</span> <span class="p">{</span> <span class="p">..</span> <span class="p">};</span>

<span class="nx">process</span><span class="p">(</span> <span class="nx">someReallyBigData</span> <span class="p">);</span>

<span class="kd">var</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span> <span class="s2">"my_button"</span> <span class="p">);</span>

<span class="nx">btn</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span> <span class="s2">"click"</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">click</span><span class="p">(</span><span class="nx">evt</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"button clicked"</span><span class="p">);</span>
<span class="p">},</span> <span class="cm">/*capturingPhase=*/</span><span class="kc">false</span> <span class="p">);</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">click</code>函数的点击处理回调完全不需要<code class="highlighter-rouge">someReallyBigData</code>变量。这就是说，理论上<code class="highlighter-rouge">process(..)</code>执行之后，这个占用很多内存的数据结构就可以被当做垃圾回收了。但是，JS引擎似乎（取决于引擎具体实现）还保存着这个数据。</p>

<p>块级作用域可以解决这个问题，只需告诉引擎 <code class="highlighter-rouge">someReallyBigData</code>不需要再保存了：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do something interesting</span>
<span class="p">}</span>

<span class="c1">// 任何在块中声明的东西之后就可以滚了!</span>
<span class="p">{</span>
	<span class="kd">let</span> <span class="nx">someReallyBigData</span> <span class="o">=</span> <span class="p">{</span> <span class="p">..</span> <span class="p">};</span>

	<span class="nx">process</span><span class="p">(</span> <span class="nx">someReallyBigData</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span> <span class="s2">"my_button"</span> <span class="p">);</span>

<span class="nx">btn</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span> <span class="s2">"click"</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">click</span><span class="p">(</span><span class="nx">evt</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"button clicked"</span><span class="p">);</span>
<span class="p">},</span> <span class="cm">/*capturingPhase=*/</span><span class="kc">false</span> <span class="p">);</span>
</code></pre>
</div>

<p>为变量声明明确的块用来本地绑定是一个强大的工具，足以加入你的代码工具箱了。</p>

<h4 id="let-循环"><code class="highlighter-rouge">let</code> 循环</h4>

<p><code class="highlighter-rouge">let</code>闪耀的另一个场景就是在前面讨论过的for循环例子中。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">i</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">i</span> <span class="p">);</span> <span class="c1">// ReferenceError</span>
</code></pre>
</div>

<p>在for循环头部的<code class="highlighter-rouge">let</code>不仅把<code class="highlighter-rouge">i</code>绑定到了循环体中，事实上，它还在每次循环迭代中重建了变量<code class="highlighter-rouge">i</code>，以确保<code class="highlighter-rouge">i</code>被重新赋予前面迭代结果的值。</p>

<p>这是另一种每次迭代绑定行为的例子：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
	<span class="kd">let</span> <span class="nx">j</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// re-bound for each iteration!</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">i</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>每次迭代绑定为什么有趣的原因会在第五章讨论闭包时水落石出。</p>

<p>因为<code class="highlighter-rouge">let</code>声明依附于任意块而非闭合函数作用域，所以不难理解用<code class="highlighter-rouge">var</code>声明的隐藏代码需要依赖函数作用域，并且在重构代码时用 <code class="highlighter-rouge">let</code>代替 <code class="highlighter-rouge">var</code>要多加留意。</p>

<p>且看:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">baz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">baz</span> <span class="o">&gt;</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">baz</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// ...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>很容易就能把这段代码重构为:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">baz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">baz</span> <span class="o">&gt;</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">baz</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>但是，针对块级作用域变量这么做是就要多加小心了：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">baz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">baz</span> <span class="o">&gt;</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// &lt;-- 移动时别忘了把`bar`也带上!</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">baz</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>附录B中可以看到一种代替（更明确）的块级作用域代码风格，针对这种情况更健壮，更容易维护和重构。</p>

<h3 id="const"><code class="highlighter-rouge">const</code></h3>

<p>作为<code class="highlighter-rouge">let</code>的补充，ES6引入了<code class="highlighter-rouge">const</code>关键字，它也能创建块级作用域变量，但它的值是固定的。任何试图改变<code class="highlighter-rouge">const</code>值得操作都会引起系统报错。</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 存在于if的块级作用域中</span>

	<span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 没问题!</span>
	<span class="nx">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 报错!</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">b</span> <span class="p">);</span> <span class="c1">// ReferenceError!</span>
</code></pre>
</div>

<h2 id="总结">总结</h2>

<p>函数是JavaScript中最普通的作用域单元。在函数中声明的变量和函数会被对外“隐藏”起来，这是一种很好的软件设计原则。</p>

<p>但函数不是唯一的作用域单元。块级作用域就是用块（通常为 <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">..</span><span class="w"> </span><span class="p">}</span></code>对）包裹代码，而不单单是包裹函数。</p>

<p>从ES3开始，<code class="highlighter-rouge">try/catch</code>结构的<code class="highlighter-rouge">catch</code>就形成了一个块级作用域。</p>

<p>在ES6中，<code class="highlighter-rouge">let</code>关键字（<code class="highlighter-rouge">var</code>关键字的表亲），就被引入用来在任何代码块中声明变量。 <code class="highlighter-rouge">if (..) { let a = 2; }</code>声明了一个变量 <code class="highlighter-rouge">a</code>，它实际上劫持了<code class="highlighter-rouge">if</code>的 <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">..</span><span class="w"> </span><span class="p">}</span></code>块并且把自己依附在上面。</p>

<p>块级作用域不应该取代函数作域。两种功能应该并存，开发者们应该用好函数作用域和块级作用域在各自适合的场景去生产更好，更可读可维护的代码。</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#javascript" class="page__taxonomy-item" rel="tag">JavaScript</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#you-don-t-know-js" class="page__taxonomy-item" rel="tag">You Don't Know JS</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fa fa-fw fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2016-03-16T00:00:00+08:00">March 16, 2016</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=第三章: 函数 vs. 块级作用域 /you%20don't%20know%20js/functionvsblockscope/" class="btn btn--twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=/you%20don't%20know%20js/functionvsblockscope/" class="btn btn--facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=/you%20don't%20know%20js/functionvsblockscope/" class="btn btn--google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=/you%20don't%20know%20js/functionvsblockscope/" class="btn btn--linkedin" title="Share on LinkedIn"><i class="fa fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/you%20don't%20know%20js/what-is-scope/" class="pagination--pager" title="第一章 什么是作用域
">Next</a>
    
  </nav>

    </div>

    
    <div id="disqus_thread"></div>
  </article>

    <script>

    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://laolizi.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
    
    
      <li><a href="http://github.com/dllglishaoyi"><i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    <li><a href="/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2017 Laolizi. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>
      </footer>
    </div>

    <script src="/assets/js/main.min.js"></script>





  </body>
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96338582-1', 'auto');
      ga('send', 'pageview');

    </script>
</html>
