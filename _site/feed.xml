<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-03-28T22:51:17+08:00</updated><id>http://localhost:4000/</id><title type="html">Laolizi’s Blog</title><subtitle>An amazing website.</subtitle><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><entry><title type="html">webpack 小札: 充分利用 CommonsChunkPlugin()</title><link href="http://localhost:4000/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack-bits-getting-the-most-out-of-the-commonschunkplugin/" rel="alternate" type="text/html" title="webpack 小札: 充分利用 CommonsChunkPlugin()" /><published>2017-03-28T10:01:53+08:00</published><updated>2017-03-28T10:01:53+08:00</updated><id>http://localhost:4000/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack-bits-getting-the-most-out-of-the-commonschunkplugin</id><content type="html" xml:base="http://localhost:4000/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack-bits-getting-the-most-out-of-the-commonschunkplugin/">&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;原文地址：&lt;a href=&quot;https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318#.o691521qn&quot;&gt;webpack bits: Getting the most out of the CommonsChunkPlugin()&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;作者：Sean T. Larkin&lt;/li&gt;
    &lt;li&gt;翻译人：&lt;a href=&quot;https://github.com/dllglishaoyi&quot;&gt;李绍懿&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;webpack 核心团队喜欢不时地参与到Twitter社区中，通过&lt;a href=&quot;https://twitter.com/TheLarkInn/status/842817690951733248&quot;&gt;一些有趣并且有营养的方式分享知识&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/demo.gif&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/20170328/twitter1.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这一次，“游戏规则”很简单。安装 webpack-bundle-analyzer ，生成一张精美多彩的图片，包含了你所有的bundle，然后分享给我。作为回报，webpack团队会帮你指出一些我们能辨认的潜在问题。&lt;/p&gt;

&lt;h2 id=&quot;我们发现了什么&quot;&gt;我们发现了什么？&lt;/h2&gt;

&lt;p&gt;最常见的问题就是代码重复：重复的类库、组件、代码存在于多个（同步或异步）的bundle里！&lt;/p&gt;

&lt;h2 id=&quot;例子1很多带有重复代码的-vendor-bundle&quot;&gt;例子1：很多带有重复代码的 vendor bundle&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/20170328/case1.png&quot; alt=&quot;图片&quot; /&gt;
&lt;img src=&quot;/assets/20170328/twitter2.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    这是一个典型例子。Swizec谢谢你让我分享它。
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@swizec&quot;&gt;Swizec Teller&lt;/a&gt;人很好，分享了他的一个构建（实际上是包含了8-9个独立单页的应用）。我从中挑选了这个例子因为可以从中辨认出很多很棒的技术。让我们具体来看看：
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;/assets/20170328/case1.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    除了“FoamTree”图表之外都是应用的代码，与此同时，所有用了node_modules资源的部分都以&quot;\_vendor.js&quot; 结尾
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
我们可以从中推断出不少东西（在不看具体配置的情况下）。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;每个单页应用都仅仅在入口和vendor代码中用了 &lt;em&gt;CommonsChunkPlugin&lt;/em&gt; 插件。这创建了一个只包含来自node_modules文件代码的bundle，并且其他的bundle只包含了应用代码。以下是部分相关配置：
&lt;img src=&quot;/assets/20170328/twitter3.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;activeApps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_vendor&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;chunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isVendor&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;activeApps&lt;/em&gt; 变量代表了每个独立的入口点。&lt;/p&gt;

&lt;h2 id=&quot;机会区域&quot;&gt;机会区域&lt;/h2&gt;

&lt;p&gt;下面是我圈出来可以做一些改善的区域。
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;/assets/20170328/case1_2.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;元-缓存&quot;&gt;“元” 缓存&lt;/h2&gt;

&lt;p&gt;我们上面看到的是各种诸如 momentjs, lodash 和 jquery 的庞大类库穿插在6个甚至更多的vendor bundle中使用。把所有vendor打包到一个单独bundle的策略固然是好的，但我们也应该相同的策略应用到所有的 vendor bundle内部。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这相当于我们告诉webpack:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;嘿，webpack, 看看所有的 chunk （包括已生成的vendor），然后把出现在6个以上chunk中的模块放到一个单独的文件中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/20170328/case1_3.jpg&quot; alt=&quot;图片&quot; /&gt;
&lt;img src=&quot;/assets/20170328/twitter4.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    在这个例子中这个文件似乎被命名为“manifest.js”
&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;/assets/20170328/twitter5.png&quot; alt=&quot;图片&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
正如你所见，所有的特定模块被抽离到一个独立的文件，并且据
Swizec说，这让他们的应用大小整体下降了17%!&lt;/p&gt;
&lt;h2 id=&quot;例子2异步-chunk-之间的重复-vendor&quot;&gt;例子2：异步 chunk 之间的重复 vendor&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/20170328/twitter6.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    这是个令人印象深刻的代码拆分用法。瞧瞧这些漂亮的颜色 💓
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
所以这个代码的重复量相对整体代码不那么严重吧，然而，当你看到下面全量代码体积的图时，你会发现有三个同样的模块存在于每个异步chunk中。
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;/assets/20170328/case2.jpeg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    异步chunk就是文件名为“[number].[number].js”的文件
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
正如你在上面看见的，有2，3个相同的组件用到了四五十个异步bundle中。那么我们怎么通过 &lt;em&gt;CommonsChunkPlugin&lt;/em&gt; 解决这个问题呢？&lt;/p&gt;
&lt;h2 id=&quot;创建异步的-commons-chunk&quot;&gt;创建异步的 Commons Chunk&lt;/h2&gt;
&lt;p&gt;这个技术和第一个非常相似，我们要把配置文件中的 &lt;em&gt;async&lt;/em&gt; 属性设为 &lt;em&gt;true&lt;/em&gt; ，像这样：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;commonlazy.js&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;用同样的方式 - webpack 会扫码所有的 chunk 来查找通用模块。当async为true时，只有拆分代码的bundle才会被扫描。
由于我们并没有指定&lt;em&gt;minChunks&lt;/em&gt;，所以默认值是3。webpack相当于被告知：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;嘿，webpack, 查看所有的常规（又称懒加载）chunk，如果你找到了出现在3个以上chunk中的相同模块，那么请把它抽离到一个单独的异步通用chunk中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最终的结果就是：
&lt;img src=&quot;/assets/20170328/case2_2.jpg&quot; alt=&quot;图片&quot; /&gt;
&lt;img src=&quot;/assets/20170328/twitter7.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
可能有更大的minChunks值，来产生一个更小的commonlazy.js包
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
现在的异步chunk已经非常小了，并且所有的代码都聚合到了一个叫 &lt;em&gt;commonlazy.js&lt;/em&gt; 的文件中。由于这些bundle已经很小了，所以大小的影响直至第二次访问都不是很明显。
现在，被分隔到每个bundle中的代码少了很多，我们通过将这些通用模块放入单独的可高速缓存的chunk中来节省用户加载时间和数据的消耗。&lt;/p&gt;

&lt;h2 id=&quot;更进一步控制-minchunks-函数&quot;&gt;更进一步控制: minChunks 函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/20170328/twitter8.png&quot; alt=&quot;图片&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
如果你想要更多控制会怎么样？有时候你并不想要单个共享的bundle，因为并不是每个 &lt;em&gt;懒/入口&lt;/em&gt; chunk 都会用到它。 &lt;em&gt;minChunks&lt;/em&gt; 属性也支持 function ！！这可以让你筛选哪些模块会被加入你新的bundle中。举个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;lodash-moment-shared-bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/lodash|moment/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的例子就是说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;哟，webpack, 当你扫描模块时候，如果模块的绝对路径匹配到了lodash或者momentjs并且出现在了三个入口文件中，那么把这些模块打包到一个bundle中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以通过设置“async：true”将同样的行为应用于异步bundle。&lt;/p&gt;

&lt;h2 id=&quot;再多的控制&quot;&gt;再多的控制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/20170328/twitter9.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个 &lt;em&gt;minChunks&lt;/em&gt; 你可以为特定的入口和bundle创建更小的可缓存vendor集合。最后，你看到的可能会是这样：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lodashMomentModuleFilter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/lodash|moment/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;immutableReactModuleFilter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/immutable|react/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;lodash-moment-shared-bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lodashMomentModuleFilter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;immutable-react-shared-bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;immutableReactModuleFilter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;没有银弹&quot;&gt;没有银弹！&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;CommonsChunkPlugin()&lt;/em&gt; 或许很强大，但请记住，这些例子都有它们所适用的场景。所以当你复制粘贴这些代码片段之前，从&lt;a href=&quot;https://medium.com/@samccone&quot;&gt;Sam Saccone&lt;/a&gt;、&lt;a href=&quot;https://medium.com/@paul_irish&quot;&gt;Paul Irish&lt;/a&gt;还有&lt;a href=&quot;https://youtu.be/6m_E-mC0y3Y?t=11m38s&quot;&gt;MPDIA&lt;/a&gt;那先获得一些建议，以确保你使用的是正确方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/20170328/advice.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
在运用解决方案之前，请务必了解你的进程
&lt;/center&gt;

&lt;h2 id=&quot;从哪找到更多的例子&quot;&gt;从哪找到更多的例子？&lt;/h2&gt;
&lt;p&gt;这些只是使用和配置 &lt;em&gt;CommonsChunkPlugin()&lt;/em&gt; 的例子。要想了解更多，在我们的 webpack/webpack GitHub 核心仓库中查看 &lt;em&gt;/examples&lt;/em&gt; 目录！如果你还有更好的想法,欢迎提交PR!&lt;/p&gt;</content><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><category term="Webpack" /><summary type="html">原文地址：webpack bits: Getting the most out of the CommonsChunkPlugin() 作者：Sean T. Larkin 翻译人：李绍懿</summary></entry><entry><title type="html">是时候再给TypeScript一次机会了【译】</title><link href="http://localhost:4000/javascript/give-typescript-another-chance/" rel="alternate" type="text/html" title="是时候再给TypeScript一次机会了【译】" /><published>2017-03-22T00:00:00+08:00</published><updated>2017-03-22T00:00:00+08:00</updated><id>http://localhost:4000/javascript/give-typescript-another-chance</id><content type="html" xml:base="http://localhost:4000/javascript/give-typescript-another-chance/">&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;原文地址：&lt;a href=&quot;https://medium.freecodecamp.com/its-time-to-give-typescript-another-chance-2caaf7fabe61#.n95889k54&quot;&gt;It’s time to give TypeScript another chance&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;作者：Jason Dreyzehne&lt;/li&gt;
    &lt;li&gt;翻译人：&lt;a href=&quot;https://github.com/dllglishaoyi&quot;&gt;李绍懿&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;  自2012年起，TypeScript成为了一些相对结构化语言（像 C++ 或者 Java）的程序员转入JavaScript的一个流行的选择。但与此同时，它也受到了大量JS世界“原住民”们的无视。
&lt;br /&gt;
&lt;br /&gt;
  你可能已经听说了Angular团队最近&lt;a href=&quot;https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8&quot;&gt;为Angular 2 切换到了TypeScript&lt;/a&gt;。其他很多团队诸如 &lt;a href=&quot;https://github.com/ReactiveX/rxjs&quot;&gt;RxJS&lt;/a&gt;、
&lt;a href=&quot;https://blog.ionic.io/announcing-ionic-2-0-0-final/&quot;&gt;Ionic&lt;/a&gt;、
&lt;a href=&quot;https://cycle.js.org/&quot;&gt;Cycle.js&lt;/a&gt;、
&lt;a href=&quot;https://github.com/palantir/blueprint&quot;&gt;Blueprint&lt;/a&gt;、
&lt;a href=&quot;https://dojotoolkit.org/community/roadmap/vision.html&quot;&gt;Dojo&lt;/a&gt;、
&lt;a href=&quot;https://github.com/NativeScript/NativeScript&quot;&gt;NativeScript&lt;/a&gt;、
&lt;a href=&quot;https://github.com/palantir/plottable&quot;&gt;Plottable&lt;/a&gt;也这么做了。&lt;/p&gt;

&lt;p&gt;  倘若你已经接触 JavaScript/Node.js 有一段时间了，你很可能会认为上面这些项目的老大脑子进水了。或者他们可能已经被微软收买了。👀&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-1.jpeg&quot; alt=&quot;图片&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;有类型的javascript&quot;&gt;有类型的JavaScript？&lt;/h4&gt;
&lt;p&gt;对于刚接触这个讨论的人来说，理解JavaScript世界对类型的厌恶是很重要的。除了JS的便携性以外，简单也是JS之所以流行的一个重要因素。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“对于黑客来说，一门语言需要擅长编写各种他们想要的程序才够迷人。这意味着，它语言要擅长写一次性的程序。”—  Paul Graham （译者注：Paul Graham 是黑客与画家的作者，这段话在&lt;a href=&quot;http://paulgraham.com/popular.html&quot;&gt;《Being Popular》&lt;/a&gt;这篇文章中提到过）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于选择JavaScript作为工具的开发者来说，他们这么做常常是因为JS的灵活性。没有标准库、很少的数据结构、无类型，JavaScript开发者在实施一些新想法的时候，不需要花费太多的时间去思考细节。&lt;/p&gt;

&lt;p&gt;一些语言诸如C++在程序需要一大堆数据结构和其余的信息时，可能是和JavaScript差异最明显的时候。很多JavaScript程序员（特别是上面提到的那种），各种传统的类、样板、类型让他们感到枯燥，而且类型转换降低了他们的开发效率。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“把你在过度保护编程语言中的疲惫、委屈，和蜷缩着对自由呼吸的渴望统统都交给我吧。”—JavaScript🕊️&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;透过这个观点，很容易明白为什么很多JavaScript用户对会对带类型的JavaScript如此抵触。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里有一些见解可能有助于缓解一些恐惧.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;typescript-是有更好代码纠错能力的-javascript&quot;&gt;TypeScript 是有更好代码纠错能力的 JavaScript&lt;/h4&gt;

&lt;p&gt;有一个可能是最常见的顾虑，那就是认为TypeScript不是纯的JavaScript。这种观点认为：因为TypeScript是一个单独的语言，所以会被转译成一大坨某一天还需要被迫去调试的糟糕代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-2.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    很多人都对TypeScript是这个印象
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;TypeScript 除了已被良好测试和广泛应用之外，还值得注意的是：基于你的配置，TypeScript代码事实上只会发生很少的“转译”（如果有的话）。TypeScript只是带了一些选项的Javascrip。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-3.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TypeScript 就像一个高级的纠错器，能够检查文档，当代码没有按照预定意图使用时会发出警告。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它为未来使用你代码的用户提供了及时的反馈和更好的开发体验。这同样也是对新项目很好的测试——如果你的项目值得去检查纠正来强制遵循编码规范，你的项目很可能从 TypeScript 中获得持久的收益。&lt;/p&gt;

&lt;p&gt;TypeScript团队会在今后&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals&quot;&gt;致力于关注JavaScript&lt;/a&gt;。以便当JavaScript加入稳定的特性时，TypeScript 会进行相应的匹配和调整。&lt;/p&gt;

&lt;h4 id=&quot;typescript-消除了运行时开支&quot;&gt;TypeScript 消除了运行时开支&lt;/h4&gt;

&lt;p&gt;另一个常见的错误观念就是 TypeScript 的类型检查会存在运行时环境中，这回带来复杂度和性能开支。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
事实上，TypeScript 是一种避免运行时类型检查的好方法。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TypeScript 是一个开发/编译时的工具&lt;/strong&gt;  — 它把标准的 JavaScript 加入了可选的类型提示，然后在产出时再移除。（它同样可以把ES6 和 ES7的特性转译成现在的标准）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
TypeScript的类型提示给我们带来了所有类型的优点，然后再让类型提示消失。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;剩下仅存在运行时中关于对象类型的线索，和标准的 JavaScript 特性是一样的。（例如，当你从原型创建一个新对象时，你可能会用 &lt;em&gt;instanceof&lt;/em&gt; 来检查它的类型）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
令人啼笑皆非的是，因为 JavaScript 并没有提供标准的开发时类型检查，很多 JavaScript 类库&lt;strong&gt;重新开发了它们自己的运行时类型检测系统&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-4.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    &lt;a href=&quot;https://github.com/request/request&quot;&gt;Request&lt;/a&gt;类库中的运行时类型检查，它为用户在不正确的使用方法时提供了更好的debug体验。但它需要在运行时中需要更多的代码和更多的单元测试用例。&lt;a href=&quot;https://github.com/request/request/blob/092e1e657326626da0b8ac4cfe8752751689313b/index.js#L43-L55&quot;&gt;代码片段→&lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;这并不是这些类库的初衷，但作为好的开发体验的一部分，保证用户能在犯错时能看见清晰可执行的错误信息是必要的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
为了这个目标，很多类库在运行时大量检查传入方法的参数类型，然后抛出错误让开发者看见。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;这毫无疑问在两个世界都烂透了。&lt;/strong&gt; 这些运行时的类型检查让重要代码变得臃肿、可读性变差、单元测试代码覆盖率达到100%的难度提升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-5.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    &lt;a href=&quot;https://github.com/bcoin-org/bcoin/&quot;&gt;Bcoin&lt;/a&gt;通过提供了运行时抛出有用的错误信息提升了开发体验。但运行时的类型检查加大了维护和测试成本。这要用 TypeScript 来做的话会更高效和有帮助。 &lt;a href=&quot;https://github.com/bcoin-org/bcoin/blob/4e7df6ef875e5936bea5139d922871498b4d9586/lib/primitives/tx.js#L84-L123&quot;&gt;代码片段→&lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不使用 Typescript 的话，不仅在开发时失去了类型检查，而且还可能经常把它带到运行时中。（我希望你能有100%的测试覆盖率。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当你使用 TypeScript 时，你给用户提供了一个更好的开发体验、减少了了运行时的类型检查（除非必须的场景，如用户输入），让你的代码单元测试更容易完全覆盖。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;typescript-已由来已久&quot;&gt;TypeScript 已由来已久&lt;/h4&gt;

&lt;p&gt;可能是因为以上提到的原因，当我第一次听说 TypeScript 时，我跑的远远的。而且它是微软出品，站在了“JavaScript精华”（较少结构）的对立面。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
但现在已经不再是2012年了。TypeScript 不是 JavaScript 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_abstraction&quot;&gt;抽象漏洞&lt;/a&gt;，TypeScript 项目中有很多顶级的黑客和工程师。（我很钦佩微软能够把项目管理得这么好。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自从 TypeScript 跟踪了 ECMAScript，使用 TypeScript 就不是把你的项目锁在了一门新语言中。&lt;/strong&gt; 很多人还没有意识到这一点，所以听到这种观点并不罕见：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“维护一个 TypeScript 项目真难。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这对于我听起来就像：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“维护一个有代码检查纠错的项目真难。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你的项目出于某种原因要停止从 TypeScript 中收益了，你可以用编译器跑一下你的项目，用以把所有类型从你的代码库中移除。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;然后你就回到无类型的 JavaScript 了。&lt;/p&gt;

&lt;h4 id=&quot;长话短说&quot;&gt;长话短说&lt;/h4&gt;
&lt;p&gt;TypeScript 最近得到了很大的改进提升。如果你几年前就听说 TypeScript 了，但是在那以后却没有跟进，现在值得再看一看。&lt;/p&gt;

&lt;h3 id=&quot;什么时候用-typescript&quot;&gt;什么时候用 TypeScript&lt;/h3&gt;

&lt;h4 id=&quot;angular-为什么是-typescript&quot;&gt;&lt;a href=&quot;https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8&quot;&gt;Angular: 为什么是 TypeScript?&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一个关于Angular团队到底为什么要选择用TypeScript构建Angular 2简短的技术讨论。&lt;/p&gt;

&lt;h4 id=&quot;所有应该在typescript中编写的js类库&quot;&gt;&lt;a href=&quot;http://staltz.com/all-js-libraries-should-be-authored-in-typescript.html&quot;&gt;所有应该在TypeScript中编写的JS类库&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一篇为什么Typescript用构建JS类库是个好主意的总结，由Cycle.js 的作者、RxJS贡献者分享。&lt;/p&gt;

&lt;h4 id=&quot;深入-typescript为什么是-typescript&quot;&gt;&lt;a href=&quot;https://basarat.gitbooks.io/typescript/content/docs/why-typescript.html&quot;&gt;深入 Typescript— 为什么是 TypeScript&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一篇关于用TypeScript好处的总结。&lt;/p&gt;

&lt;h3 id=&quot;学习-typescript&quot;&gt;学习 TypeScript&lt;/h3&gt;

&lt;h4 id=&quot;typescript教程&quot;&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/tutorial.html&quot;&gt;Typescript教程&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一篇 TypeScript 团队维护的简短教程。&lt;/p&gt;

&lt;h4 id=&quot;typescript设计目标&quot;&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals&quot;&gt;Typescript设计目标&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一篇概括了TypeScript团队整体设计原则的wiki。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ts-6.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;typescript-starter&quot;&gt;&lt;a href=&quot;https://github.com/bitjson/typescript-starter&quot;&gt;typescript-starter&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一个开发JavaScript类库的脚手架工程。包含了单元测试、文档生成还有CommonJS和ES6模块引入（针对Node.js和浏览器环境）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;我抱着改变观念的希望写了这篇文章。如果有什么我可以改进这篇文章的想法，请
&lt;a href=&quot;https://twitter.com/bitjson&quot;&gt;告诉我&lt;/a&gt;
&lt;br /&gt;
如果你觉得这篇文章有趣的话，请分享并为我点赞♡，谢谢阅读！&lt;/p&gt;</content><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><category term="TypeScript" /><summary type="html">原文地址：It’s time to give TypeScript another chance 作者：Jason Dreyzehne 翻译人：李绍懿</summary></entry><entry><title type="html">React Loadable简介[译]</title><link href="http://localhost:4000/react/Introducing-React-Loadable/" rel="alternate" type="text/html" title="React Loadable简介[译]" /><published>2017-03-14T00:00:00+08:00</published><updated>2017-03-14T00:00:00+08:00</updated><id>http://localhost:4000/react/Introducing-React-Loadable</id><content type="html" xml:base="http://localhost:4000/react/Introducing-React-Loadable/">&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;原文地址：&lt;a href=&quot;https://medium.com/@thejameskyle/react-loadable-2674c59de178&quot;&gt;Introducing React Loadable&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;作者：james kyle&lt;/li&gt;
    &lt;li&gt;翻译人：李绍懿&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt; 当你的项目足够大时，把所有代码打包到一个bundle中的启动时间就会成为问题。这时就需要把app拆分为若干个bundle，然后根据需求动态加载它们。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image1.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    一个大bundle VS 若干个小bundle
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt; 那如何把一个bundle拆成几个呢？这个问题其实已经被 &lt;a href=&quot;https://github.com/substack/factor-bundle&quot;&gt;Browserify&lt;/a&gt; 和 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt; 这些工具解决得很好了。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt; 但还要做的是在项目中找到合适的地方拆分bundle，然后异步去加载。所以当项目中有东西在加载时的需要一种通信机制。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;基于路由拆分-vs-基于组件拆分&quot;&gt;基于路由拆分 vs 基于组件拆分&lt;/h3&gt;

&lt;p&gt; 通常的推荐做法就是把app根据路由进行拆分，然后异步地去加载每一个。看上去这种做法对于大多数app已经足够好，例如点击一个连接然后加载一个新页面，这种体验还不赖。
&lt;br /&gt;
&lt;br /&gt;
 但是，我们可以做得更好。
&lt;br /&gt;
&lt;br /&gt;
 其实在大多数React的路由管理工具中，路由以组件的形式存在。它们并没有什么非常特别的地方。所以假设我们围绕着组件优化而不是把责任推给路由会怎么样？这样会给我们带来什么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image2.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;center style=&quot;font-size:12px;color:#9a9a9a&quot;&gt;
    基于路由 VS 基于组件代码拆分
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
 这会有很多结果。相比只是简单根据路由拆分app，这样做会有更多地方可以拆分。例如 Modals、tabs ，还有很多在用户做相应操作之前隐藏内容的组件。
&lt;br /&gt;
&lt;br /&gt;
 更别说那些需要推迟到高优先级内容加载完成后才加载的内容了。一个在页面底部而且依赖了一大串类库的组件为什么要和页面顶部的内容同时加载呢？
&lt;br /&gt;
&lt;br /&gt;
 你大可依然在路由只是简单组件时拆分他们。对于你的app，不管黑猫白猫，捉到老鼠就是好猫。
&lt;br /&gt;
&lt;br /&gt;
 但我们需要在让组件层面拆分app像在路由层面拆分一样简单。简单得只要改几行代码，其他的事就自动OK。&lt;/p&gt;

&lt;h3 id=&quot;react-loadable简介&quot;&gt;React Loadable简介&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
 React Loadable 是一个很小的库，是我&lt;a href=&quot;https://twitter.com/thejameskyle/status/839916840973299713&quot;&gt;厌烦了你们总说这个很难做&lt;/a&gt; 之后写出来的。
&lt;br /&gt;
&lt;br /&gt;
 Loadable 是一个高阶组件（创建组件的function）用来轻易地在组件层面拆分bundle。
&lt;br /&gt;
&lt;br /&gt;
 我们试想一下有两个组件，其中一个引入并渲染了另一个。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 此时我们依赖了AnotherComponent并且通过import关键字同步引入。我们需要一种让它异步加载的方法。
&lt;br /&gt;
&lt;br /&gt;
 使用ECMA中&lt;strong&gt;动态引用&lt;/strong&gt;（&lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;一个T39提案，目前stage3&lt;/a&gt; ）的特性来修改我们的组件使之异步加载AnotherComponent。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;AnotherComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;componentWillMount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnotherComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 然而，这只是手动做法，并不适用大量其他各种各样的场景。比如说当import()失败的情况，以及服务端渲染的情况。
&lt;br /&gt;
&lt;br /&gt;
 作为替代，你可以使用 Loadable 把问题抽象出来。Loadable的用法很简单。你仅仅要做的就是把要加载的组件和当你加载组件时的“Loading”组件传入一个方法中。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Loadable&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react-loadable'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LoadableAnotherComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Loadable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LoadableAnotherComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 但是如果组件加载失败怎么办，我们还需要一个错误状态提示。
为了让你最大化控制要显示的东西，错误提示只是简单地作为LoadingComponent的一个prop传入。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;基于import的自动代码拆分&quot;&gt;基于import()的自动代码拆分&lt;/h4&gt;

&lt;p&gt; import()的牛X之处在于 Webpack 2 可以自动拆分代码，不论你在何时加入新代码，都不用做其他额外的工作。
&lt;br /&gt;
&lt;br /&gt;
 这意味着你在使用 React Loadable 时，你可以通过切换 import() 位置来轻易试验代码拆分点，以便让你的app达到最佳性能。&lt;a href=&quot;https://github.com/thejameskyle/react-loadable-example&quot;&gt;你可以在这查看示例工程&lt;/a&gt;。或者&lt;a href=&quot;https://webpack.js.org/guides/code-splitting-import/&quot;&gt;查看 Webpack 2 文档&lt;/a&gt;（提示：一些相关文档在&lt;a href=&quot;https://webpack.js.org/guides/code-splitting-require//&quot;&gt;require.ensure()&lt;/a&gt; 一节中）
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;避免组件加载闪烁&quot;&gt;避免组件加载闪烁&lt;/h4&gt;
&lt;p&gt; 有时组件加载非常快(&amp;lt;200ms)，这时加载中的样式就会一闪而过。
&lt;br /&gt;
&lt;br /&gt;
 有大量用户研究表明，这样会让用户感觉到比实际加载更长的等待时间。如果什么都不显示的话，用户会感觉更快。所以Loading组件需要接收一个pastDelay prop。
&lt;br /&gt;
&lt;br /&gt;
 这样你的Loading组件只在加载时间比设定delay时间长时才会显示。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pastDelay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pastDelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 这个 delay 默认200ms，但你也可以给Loadable传入第三个参数用来自定义这个值。
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;Loadable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;预加载&quot;&gt;预加载&lt;/h4&gt;

&lt;p&gt; 作为优化，你也可以在组件渲染之前对它进行预加载。举个例子，当你需要在点击按钮时加载一个新组建，可能需要用户hover在按钮上时就预加载它。
&lt;br /&gt;
&lt;br /&gt;
 Loadable 创建的组件向外暴露了一个用于预加载的静态方法，具体如下：
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LoadableMyComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Loadable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;showComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;showComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;onMouseOver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;LoadableMyComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onMouseOver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onMouseOver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;Show&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loadable&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;component&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/button&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;showComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LoadableMyComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;服务端渲染&quot;&gt;服务端渲染&lt;/h4&gt;

&lt;p&gt; Loadable 通过控制最后一个参数同样支持服务端渲染。服务端运行时，通过传入要动态加载模块的绝对路径来允许 Loadable 同步 reqire() 模块。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'path'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LoadableAnotherComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Loadable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyLoadingComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'./another-component'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt; 这意味着你的“异步加载”和“代码拆分”模块在服务端都是同步渲染。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt; 此时在客户端遇到的问题回来了。我们可以在服务端完整渲染应用，但在客户端，我们同一时间只需要加载一个bunle。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 设想一下如果我们能弄清楚服务端bundling进程中哪些bundle是我们所需的会怎样？这样我们就可以把这些bundle一下传给客户端并且带上服务端渲染的确切状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 今天你其实离这个目标很近了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 因为我们在Loadable中掌握了所有server端依赖的路径，我们可以添加一个新的&lt;em&gt;flushServerSideRequires&lt;/em&gt;方法用来返回所有在服务端渲染的路径。然后用&lt;em&gt;webpack –json&lt;/em&gt;命令，我们就可以获得一个匹配了对应文件的bundle（&lt;a href=&quot;https://gist.github.com/thejameskyle/abecfe8ec2a7ce1e312a904527a31908&quot;&gt;我的具体代码&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 仅剩的问题就是如何在客户端优美地使用 Webpack 。我会在发表完这篇文章后一直等待你们的消息。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 这就是所有的“酷玩意”（原文：“cool shit”），我们可以把它们优雅地结合在一起。&lt;em&gt;React Fiber&lt;/em&gt;（译者注：&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;React Fiber是React核心算法的重写&lt;/a&gt;）让我们更智能指定哪些bundle需要直接传输而哪些需要推迟到更高优的工作完成后再加载。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 最后，请您把这玩意安装上再&lt;a href=&quot;https://github.com/thejameskyle/react-loadable&quot;&gt;帮给我的repo给颗星&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loadable&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;or&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;save&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loadable&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/thejameskyle&quot;&gt;我也在twitter上&lt;/a&gt;&lt;/p&gt;</content><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><category term="React" /><summary type="html">原文地址：Introducing React Loadable 作者：james kyle 翻译人：李绍懿</summary></entry><entry><title type="html">第一章 什么是作用域</title><link href="http://localhost:4000/you%20don't%20know%20js/what-is-scope/" rel="alternate" type="text/html" title="第一章 什么是作用域" /><published>2016-03-25T00:00:00+08:00</published><updated>2016-03-25T00:00:00+08:00</updated><id>http://localhost:4000/you%20don't%20know%20js/what-is-scope</id><content type="html" xml:base="http://localhost:4000/you%20don't%20know%20js/what-is-scope/">&lt;p&gt;在变量中保存值、读取或修改值的能力是几乎所有编程语言的基本范例之一。实际上，在变量中储存和读取值得能力给了程序域的概念。&lt;/p&gt;

&lt;p&gt;如果没有这个概念，程序可以运行一些任务，但是它们会非常受限和无趣。&lt;/p&gt;

&lt;p&gt;但是，变量概念在我们程序中的引入带来了我们接下来要解决的有趣问题：变量们都“生活”在哪里？换句话说，它们被储存在哪里？还有，最重要的是，我们的程序怎么在需要的时候找到它们？&lt;/p&gt;

&lt;p&gt;接下来要讨论的问题就是，怎么样很好地定义一套变量存储规则并且随后能够读取。我们把这套规则称之为：&lt;em&gt;作用域&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;编译原理&quot;&gt;编译原理&lt;/h2&gt;

&lt;p&gt;它可以是显而易见的，但也可能是意想不到的，这取决于你跟各种语言交互的程度，尽管JavaScript通常被冠以动态和解释型语言的名号，但实际上它是一种编译型语言。但它相比各种传统编译型语言和分布式系统的编译结果而言，JavaScript并不是事先编译好的。&lt;/p&gt;

&lt;p&gt;然而，JavaScript引擎依然要做一些和传统语言编译器相同的步骤，有时复杂得可能超出我们的想象。&lt;/p&gt;

&lt;p&gt;对于传统编译型语言，源代码在执行前通常要经历三个步骤，姑且称之为&lt;em&gt;编译&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;1.&lt;em&gt;标记&amp;amp;词法分析&lt;/em&gt;：
        把字符串拆分成一系列被称为“tokens”的有意义片段。比如，程序语句：var a = 2;。会被拆分为以下标记（token）：“var”,“a”,“=”,“2”,“;”。空格根据其是否有意义来决定是否被生成标记。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;：标记和词法分析的区别比较微妙而且比较专业，核心在于token被标记为无状态（stateless）和有状态（statsful）的方式。简单来说，如果标记解析器行使有状态解析规则用以指出a是否为一个标记或者其他标记的一部分，那么这就是词法分析。&lt;/p&gt;

&lt;p&gt;2.&lt;em&gt;解析&lt;/em&gt;：
	解析过程就是把标记流转化为一棵树，这棵树是嵌套元素格式的，并且符合程序的语法结构。
这棵树被称为”AST” (虚拟语法树)。
	对于var a = 2;的语法树，以一个被称为“变量声明”的顶级节点开始，包含两个子节点，一个叫做标识符（值为“a”），另一个子节点叫做赋值表达式，并且这个赋值表达式节点包含其自己的一个子节点，叫做数字字面值（值为“2”）。&lt;/p&gt;

&lt;p&gt;3.&lt;em&gt;代码生成&lt;/em&gt;：
	这就是把虚拟语法树生成可执行代码的过程。对于不同的程序语言和平台，这个过程会有很大的不同。
因此，相比于陷入具体细节的泥潭，只要知道，var a = 2;的语法树最终会被转化为一系列机器指令，负责创建一个变量a并吧一个值储存在变量a中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;：介于JS引擎如何管理系统资源比起我们要讨论的话题太过深入，我们只要知道JS引擎有能力按需存储变量就好了。&lt;/p&gt;

&lt;p&gt;JavaScript引擎和其他大多数语言一样，要做的事实际上是要比以上三步复杂得多的。举个例子，在解析和代码生成的过程中，有一些诸如合并冗余元素的优化步骤。&lt;/p&gt;

&lt;p&gt;所以我在这里只是粗略概括了一下，但我想你会很快看到，为什么我们做的这些细节，即使你在一个很高的水平，都是相关的。
有一点要注意，JavaScript引擎并没有像其他语言编译器一样，奢侈的话费大量时间去做优化，因为JavaScript不会像其他语言一样在构建前完成编译。
JavaScript在很多时候，从代码的编译到执行只需要几微秒甚至更少的时间！为了确保最快的性能，JavaScript用到了各种各样的技巧（例如JITS，用于懒编译甚至热重编），这些已经超出了这里要讨论“域”的范畴。
简单起见，我们只需要知道任何JavaScript代码片段在执行前都需要编译。因此var a = 2;也不例外。&lt;/p&gt;

&lt;p&gt;理解作用域
在学习作用域的路上，需要理解会话的过程，但什么是会话呢？
角色们
让我们先见识一下在与var a = 2;交互的过程中，有哪些角色参与其中吧，这样我们就能很快理解他们之间的会话了：
	1.引擎：负责JavaScript程序从头到尾的编译和执行。
	2.编译器:引擎的朋友之一，负责处理一下诸如解析和代码生成的脏活累活。
	3.作用域：引擎的另一个朋友，负责收集和管理所有已声明变量的查找表，并且强制用一套严	   格的规则让他们可被正运行的代码取得。&lt;/p&gt;

&lt;p&gt;为了让你完全理解JavaScript是如何运作的，你需要像引擎和他的朋友们一样去思考，问它们会问的问题，并且能够回答它们。&lt;/p&gt;

&lt;p&gt;来来回回
当你看到var a = 2;这段程序时，你很可能把它理解成一个声明语句。但我们的朋友引擎可不这么想。事实上，引擎看到了两个不同的声明，一个是编译器将会在编译阶段处理的，另一个则由引擎在执行阶段处理。
那么，就让我们来看看引擎和它的朋友们到底是怎么处理var a = 2;的吧。&lt;/p&gt;

&lt;p&gt;编译器首先要对这段程序做进行词法分析，转化为一系列标记，然后把标记生成语法树。但当编译器要做代码生成时，它对程序的处理会比假设的有一些不同。&lt;/p&gt;

&lt;p&gt;编译器假定的代码生成过程是这样的：
	为变量分配内存空间
	把变量标记为a
	然后把2赋值给变量
遗憾的是，这个过程并不准确。&lt;/p&gt;

&lt;p&gt;而确切的过程是这样的：
	1.当遇到 var a 时，编译器会询问作用域是否有一个变量a已经存在其中。如果有，编译器会忽略这个声明。反之，编译器会要求作用域在其中声明一个名叫a的变量。
	2.编译器随后会为引擎生成a = 2的可执行代码。引擎在执行这些代码的时候会首先询问当前作用域是否有一个可达到的变量a。如果有，就使用这个变量。如果没有，引擎将会去别处寻找（见下文嵌套作用域部分）。&lt;/p&gt;

&lt;p&gt;如果引擎最终找到a变量，就会给它赋值2。反之引擎会报错。&lt;/p&gt;

&lt;p&gt;变量操作的两个动作总结为：第一，编译器声明一个变量（如果在当前作用域没声明过的话）。第二，代码执行阶段，引擎如果在作用域中找到变量，就为其赋值。&lt;/p&gt;

&lt;p&gt;聊聊编译器
我们需要几个专业术语以便更深入理解。
在第二部中，引擎执行编译器的产出代码时需要找到是否有被声明的变量a，这个查找是在作用域中进行的。引擎的类型会影响查找结果。&lt;/p&gt;

&lt;p&gt;在我们的例子中，引擎查找a变量时，表现为“LHS”型。另一种查找类型被称为“RHS”。&lt;/p&gt;

&lt;p&gt;我打赌你已经猜出了 “L” 和 “R”的含义。这两个术语分别代表了”Left-hand Side” （左手边）和 “Right-hand Side”（右手边）。&lt;/p&gt;

&lt;p&gt;“边”又是什么意思？代表从那边开始赋值操作。
换句话说 “LHS”型的查找将会在变量出现在赋值操作的左边时完成。“LHS”型则反之。
“RHS”型查找其实在我们这么简单的目的（找到某些变量的值）中表现得比较模糊，然而LHS负责找到变量以便赋值。在这种情况下，RHS并不真正意味着“赋值表达式的右边”，而意味着“不在左边”。&lt;/p&gt;

&lt;p&gt;你可以简单认为RHS意味着取值。&lt;/p&gt;

&lt;p&gt;让我们深入一些讨论：
现有代码：&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是一个RHS引用，因为a并没有在这里赋值。我们在这里找到并取出变量a的值，以便把值传给console.log(..)。
另一种情况：
a = 2;
对于a是LHS的引用，因为我们并不关心它现在的值，我们只是想找到=2表达式的赋值目标。&lt;/p&gt;

&lt;p&gt;备注： LHS 和 RHS代表在赋值的左/右边，并不一定要在=号的左/右边。有几种赋值的方式，所以这两个概念被定义为：“赋值的目标（LHS）”和“赋值的来源（RHS）”。&lt;/p&gt;

&lt;p&gt;一下的程序同时涵盖了 LHS 和 RHS 引用：
function foo(a) {
    console.log( a ); // 2
}&lt;/p&gt;

&lt;p&gt;foo( 2 );&lt;/p&gt;

&lt;p&gt;最后一行调用了foo(..)，需要获得foo的RHS，意味着，“查找foo的值
，然后把它给我”。此外(..)表明foo的值需要被执行，所以它最好是一个方法！&lt;/p&gt;

&lt;p&gt;这其中有一个细微却很重要的赋值，你发现了吗？
你可能会忽略其中a=2的含蓄代码片段。它发生在2被当做参数传给foo(..)方法时，这个时候，参数a被赋值2。给a（含蓄的）赋值时，LHS查找发生了。&lt;/p&gt;

&lt;p&gt;其中也有值a的RHS引用，其值被传给了console.log(..)。console.log(..)执行需要一个引用。这就是console对象的RHS查找，然后再看它是否存在一个叫做log的属性方法。&lt;/p&gt;

&lt;p&gt;最后，把值2（通过变量a的RHS查找获得）传入log(..)的过程我们可以概念化为有LHS/RHS交换。抛开log(..)实际的原生实现，我们可以假设它有一些参数，其中第一个（可能被叫做arg1）在被赋值2之前有一次LHS引用查找。&lt;/p&gt;

&lt;p&gt;不管怎样，细微但重要的差别在于，编译器在代码生成阶段，需要处理声明和值得定义，而引擎在代码执行阶段，把一个方法赋值给foo并不是必要的。因此，在我们的讨论中，真的不必要吧方法声明看作是LHS查找赋值。&lt;/p&gt;

&lt;p&gt;引擎/作用域的对话&lt;/p&gt;

&lt;p&gt;function foo(a) {
    console.log( a ); // 2
}&lt;/p&gt;

&lt;p&gt;foo( 2 );&lt;/p&gt;

&lt;p&gt;让我们把上面的交换（代码片段的执行过程）想象成一次对话。这段对话可能会是这样：&lt;/p&gt;

&lt;p&gt;引擎：嘿，作用域，我有一个foo的RHS引用。听说过吗？&lt;/p&gt;

&lt;p&gt;作用域: 当然。编译器一秒前刚声明过，是一个方法。&lt;/p&gt;

&lt;p&gt;引擎：太棒了，谢谢！我正在执行foo。&lt;/p&gt;

&lt;p&gt;引擎：嘿，作用域，我有一个a的LHS引用。听说过吗？&lt;/p&gt;

&lt;p&gt;作用域: 当然。编译器刚把它声明为一个形参。&lt;/p&gt;

&lt;p&gt;引擎: 一如既往的有帮助呀，作用域，再次感谢。现在是时候给a赋值2了。&lt;/p&gt;

&lt;p&gt;引擎：嘿，作用域，抱歉又来烦你了。我需要一个console的RHS查找，听说过吗？&lt;/p&gt;

&lt;p&gt;作用域: 没问题，引擎，这是我每天做的事。好，我找到console了，&lt;/p&gt;

&lt;p&gt;引擎：完美。找下log(..)。好的，他是个function。&lt;/p&gt;

&lt;p&gt;引擎：Yo，作用域。我需要a的RHS引用。我觉得我记住它了，你只要帮我确认一下它没变化就好了。&lt;/p&gt;

&lt;p&gt;作用域：是的，它没变。&lt;/p&gt;

&lt;p&gt;引擎：酷。把a的值给我一下，它是2，放到log(..)里去
…&lt;/p&gt;

&lt;p&gt;小测验
检测一下你到目前为止的理解程度。确保你掌握了引擎和其与作用域之间的“对话”。&lt;/p&gt;

&lt;p&gt;function foo(a) {
    var b = a;
    return a + b;
}&lt;/p&gt;

&lt;p&gt;var c = foo( 2 );&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找出所有的LHS查找（一共三个） &lt;/li&gt;
  &lt;li&gt;找出所有的RHS查找（一共四个） 
注释: 答案在后面的回顾章节中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;嵌套作用域
我们说过作用域是一套根据标识符名查找变量的规则。但我们往往要考虑多个作用域。就像一个函数内嵌了另一个函数，作用域也会被嵌套在别的作用域当中。所以，如果一个变量无法在当前作用域中找到，引擎就会去外层包裹的作用域中查找，直至找到变量或者已达最外层作用域。&lt;/p&gt;

&lt;p&gt;且看以下代码:
function foo(a) {
    console.log( a + b );
}&lt;/p&gt;

&lt;p&gt;var b = 2;&lt;/p&gt;

&lt;p&gt;foo( 2 ); // 4&lt;/p&gt;

&lt;p&gt;b的RHS引用无法在foo方法中被找到，但可以在其外层作用域（在这个例子中，是全局作用域）找到。&lt;/p&gt;

&lt;p&gt;所以，引擎和作用域间的对话会是这样：&lt;/p&gt;

&lt;p&gt;引擎：“嘿，foo的作用域，你知道b吗？我需要一个它的RHS引用。”
作用域：“没听过。自己想办法吧。”
引擎：“嘿，foo外层的作用域，原来你是全局作用域呀，真酷。你知道b吗？我需要一个它的RHS引用。”
作用域：“有的，拿去用吧。”&lt;/p&gt;

&lt;p&gt;穿越作用域的规则很简单：引擎从当前作用域开始寻找变量，若没找到，就进入上一级作用域，重复此步骤。如果到达最外层的全局作用域，搜索停止，不管是否找到变量。&lt;/p&gt;

&lt;p&gt;比作楼房&lt;/p&gt;

&lt;p&gt;为了使嵌套作用域更加形象，我希望你把它想成一栋高楼。&lt;/p&gt;

&lt;p&gt;￼&lt;/p&gt;

&lt;p&gt;这栋楼房相当于我们程序中作用域的规则。一楼就是你当前所处的作用域，顶层就是全局作用域。
你在当前楼层中找LHS和 RHS 引用，如果没有找到，坐电梯上一层接着找，重复这个过程。当你上到顶楼（全局作用域）时，不管有没有找到想要的东西，你都得停下来了。&lt;/p&gt;

&lt;p&gt;错误&lt;/p&gt;

&lt;p&gt;为什么要在乎叫做LHS还是RHS？&lt;/p&gt;

&lt;p&gt;因为这两种查找在变量未声明的时候（在所有询问的作用域中都没有找到）表现为不同的行为。&lt;/p&gt;

&lt;p&gt;且看：&lt;/p&gt;

&lt;p&gt;function foo(a) {
    console.log( a + b );
    b = a;
}&lt;/p&gt;

&lt;p&gt;foo( 2 );&lt;/p&gt;

&lt;p&gt;查找变量b时RHS查找被首次触发，这时b就是一个未声明的变量，因为在作用域中找不到它。&lt;/p&gt;

&lt;p&gt;如果一个RHS查找变量失败了，包括在嵌套的作用域中，这样会导致一个ReferenceError 错误被引擎抛出。知道这个错误是ReferenceError类型的非常重要。&lt;/p&gt;

&lt;p&gt;相比之下，如果引擎在做一个LHS查找的时候到达了顶楼却没有找到目标变量，而程序并不在“严格模式下”运行，全局作用域中就会自动创建一个相应名字的变量，并把它交给引擎。&lt;/p&gt;

&lt;p&gt;“没有你想要的变量，但能干的我会帮你创建一个。”&lt;/p&gt;

&lt;p&gt;“严格模式”，在ES5中加入的特性，一种相较于正常/宽松/懒模式有很多不同行为的模式。其中的一个行为表现就是禁止全局变量的自动创建。全局模式在上面的例子中，LHS查找就得不到一个全局变量，引擎就会抛出一个ReferenceError错误。&lt;/p&gt;

&lt;p&gt;现在，如果一个变量被RHS查找到了，但你尝试把它当做一些不可能的值来操作，类似把一个非函数当做函数来执行，或者对null/undefined引用属性，引擎就会抛出另一个类型的错误，叫做TypeError。ReferenceError是跟作用域查找失败有关的，而TypeError暗示了作用域查找成功，但把结果当做一个非法/不可能的值来处理了。&lt;/p&gt;

&lt;p&gt;回顾&lt;/p&gt;

&lt;p&gt;作用域就是一系列规定变量如何被找到的规则。查找可以是为了赋值，这就是LHS引用，也可以是为了取值，即RHS引用。&lt;/p&gt;

&lt;p&gt;LHS引用了赋值操作的结果。基于作用域的赋值既能在使用=操作符时发生，也能在把参数传给方法时发生。&lt;/p&gt;

&lt;p&gt;JavaScript引擎会在代码执行前编译， var a = 2;在这个过程中会被分两步拆分：
	1.首先，var a会在作用域中声明变量。它会在被执行前提升到作用域最前端。
	2.然后，a = 2回去查找变量（LHS引用），并且找到后赋值。&lt;/p&gt;

&lt;p&gt;LHS 和 RHS引用查找都会在当前执行的作用域中开始，如果需要的话，它们的工作会延伸到外层嵌套的作用域，每次在一个作用域中查找，直至顶层。&lt;/p&gt;

&lt;p&gt;RHS查找不成功会抛出ReferenceErrors错误，LHS查找不成功则会创建相应的全局变量（非严格模式），或者也抛出ReferenceError错误（严格模式下）。&lt;/p&gt;

&lt;p&gt;测试答案
function foo(a) {
    var b = a;
    return a + b;
}&lt;/p&gt;

&lt;p&gt;var c = foo( 2 );&lt;/p&gt;

&lt;p&gt;1.找出所有的LHS查找（一共三个）
	c = ..， a = 2 (隐晦的参数赋值) ， b = .. 
2.找出所有的RHS查找（一共四个）
	foo(2..， = a;， a + .. ， .. + b &lt;/p&gt;</content><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><category term="JavaScript" /><summary type="html">在变量中保存值、读取或修改值的能力是几乎所有编程语言的基本范例之一。实际上，在变量中储存和读取值得能力给了程序域的概念。</summary></entry><entry><title type="html">第三章: 函数 vs. 块级作用域</title><link href="http://localhost:4000/you%20don't%20know%20js/functionvsblockscope/" rel="alternate" type="text/html" title="第三章: 函数 vs. 块级作用域" /><published>2016-03-16T00:00:00+08:00</published><updated>2016-03-16T00:00:00+08:00</updated><id>http://localhost:4000/you%20don't%20know%20js/functionvsblockscope</id><content type="html" xml:base="http://localhost:4000/you%20don't%20know%20js/functionvsblockscope/">&lt;h1 id=&quot;你不知道的js作用域和闭包&quot;&gt;你不知道的JS:作用域和闭包&lt;/h1&gt;
&lt;h1 id=&quot;第三章-函数-vs-块级作用域&quot;&gt;第三章: 函数 vs. 块级作用域&lt;/h1&gt;

&lt;p&gt;我们在第二章探索过，作用域由一系列“泡泡”组成，这些“泡泡”就像装着标识符（变量、方法）的桶。这些“泡泡”整齐地嵌套，并且这些嵌套在写代码时就定义好了。&lt;/p&gt;

&lt;p&gt;但到底是什么构造了一个新的泡泡？只能是函数吗？JavaScript中还有别的什么结构能创造作用域泡泡呢？&lt;/p&gt;

&lt;h2 id=&quot;函数作用域&quot;&gt;函数作用域&lt;/h2&gt;

&lt;p&gt;对于这些问题，最普通的答案莫过于JavaScript拥有基于函数的作用域了。就是说，你声明的每个函数都为它自己创造了一个泡泡，但没别的结构能为自己创建泡泡了。我们来看看为什么这么说，尽管这不是特别准确。&lt;/p&gt;

&lt;p&gt;首先，我们来看看函数作用域和它的实现。&lt;/p&gt;

&lt;p&gt;有如下代码：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// some code&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// more code&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这段代码当中，&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(..)&lt;/code&gt;的作用域泡泡包含了标识符&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;。不论在作用域的那个地方声明变量，变量和方法都属于这个作用域泡泡。这一点我们会在下一章具体讨论。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bar(..)&lt;/code&gt;拥有它自己的作用域泡泡。全局作用域也有一个属于自己的泡泡，它只包含一个名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的标识符。&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;都属于&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(..)&lt;/code&gt;的作用域泡泡，他们是无法从&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(..)&lt;/code&gt;外面访问的。也就是说，以下的代码会引起&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;报错，因为这些标识符是无法从全局作用域访问的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 失败&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 三个都失败&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然而, 所有的这些标识符 (&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;)是可以从&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(..)&lt;/code&gt;的 &lt;em&gt;外部&lt;/em&gt;访问的, 而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar(..)&lt;/code&gt;内部也可以访问 (假设&lt;code class=&quot;highlighter-rouge&quot;&gt;bar(..)&lt;/code&gt;内没有声明覆盖他们).&lt;/p&gt;

&lt;p&gt;函数作用域鼓励一直思想：所有变量属于函数，函数内部（甚至在内部的嵌套作用域中）处处可以访问他们。这种设计方式是非常有用的，它可以把JavaScript按需处理不同类型值得动态特性发挥到极致。&lt;/p&gt;

&lt;p&gt;另一方面，如果你疏于防范，存在于整个作用域中的变量会产生一些意想不到的隐患。&lt;/p&gt;

&lt;h2 id=&quot;藏在作用域中&quot;&gt;藏在作用域中&lt;/h2&gt;

&lt;p&gt;通常对函数的想法就是声明一个函数，然后再在其中加入代码。其实反过来也同样强大和有用：选择一段你写过的代码，然后用一个函数声明把它包裹起来，这样就“隐藏”了这段代码。&lt;/p&gt;

&lt;p&gt;这样实际上是创造了一个环绕代码的作用域泡泡，也就是说，任何代码中的声明（变量和方法）现在都会被新的函数作用域包裹起来。换句话说，你可以通过用函数作用域包裹的方法吧变量“隐藏”起来。&lt;/p&gt;

&lt;p&gt;为什么说“隐藏”变量和函数是一种有用的技术呢？&lt;/p&gt;

&lt;p&gt;有几个原因。它们遵循了软件设计原则中的“最小权限原则”。在软件设计中，例如一个对象的API，这个原则表现为向外暴露最少量的东西以满足需求，然后隐藏其他所有的东西。&lt;/p&gt;

&lt;p&gt;这个原则扩展了用哪个作用域来包含变量和函数。如果所有的变量和函数都在全局作用域中，它们当然可以被所有的嵌套作用域访问。但这违背了“最小…”原则。这暴露了很多本该私有化的变量和方法，这种完全的用法会让变量/方法的访问变得不美。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在这段代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 变量和 &lt;code class=&quot;highlighter-rouge&quot;&gt;doSomethingElse(..)&lt;/code&gt; 方法从他们所做的事来看应该是“私有的”。把他们的入口暴露在外不但是不必要的，而且可能会是“危险”的，他们可能被一些不希望的方式有意无意地调用， 而且还可能打乱&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething(..)&lt;/code&gt;执行的前提条件。&lt;/p&gt;

&lt;p&gt;把这些私密的细节隐藏在&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething(..)&lt;/code&gt;的作用域中，将会是个更恰当的设计：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;现在，&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;doSomethingElse(..)&lt;/code&gt; 无法从外部访问了,取而代之的是只能对 &lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething(..)&lt;/code&gt;的控制。这样做对功能性和结果并没有什么影响，但这种设计把细节私有化，这是一种更好的软件实践。&lt;/p&gt;

&lt;h3 id=&quot;冲突避免&quot;&gt;冲突避免&lt;/h3&gt;

&lt;p&gt;隐藏变量和方法的另一个好处就是可以避免两个同名标识符的冲突。这种冲突常常是因为意外覆盖了值引起的。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 改变了for循环中 `i` 的值&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// oops, 死循环!&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar(..)&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;i = 3&lt;/code&gt;的赋值意外覆盖了&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(..)&lt;/code&gt;中for循环里声明的&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;。此时，引发了一个死循环，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;被赋予了一个固定值 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; ，永远小于10。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bar(..)&lt;/code&gt;里的赋值需要声明一个本地变量，无所谓标识符叫什么名字。 &lt;code class=&quot;highlighter-rouge&quot;&gt;var i = 3;&lt;/code&gt;能解决这个问题（会为&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;创建一个我们前面提到的“阴影变量”声明）。&lt;/p&gt;

&lt;h4 id=&quot;全局命名空间&quot;&gt;全局命名空间&lt;/h4&gt;

&lt;p&gt;在你程序中引入的多个类库如果不完全隐藏它们的内部/私有的方法和变量，和容易引起冲突。&lt;/p&gt;

&lt;p&gt;这些类库通常会创建一个单独的变量声明，经常是一个在全局作用域中拥有唯一名字的对象。这个对象会运用是一个属于这个类库自己的“命名空间”，所有对外暴露的函数都表现为对象（命名空间）的属性，而不是顶层作用域中的标识符。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyReallyCoolLibrary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;awesome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stuff&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;doAnotherThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;模块管理&quot;&gt;模块管理&lt;/h4&gt;

&lt;p&gt;另一种避免冲突的方法就是模块化，运用一些依赖管理器。通过运用这些工具，就再也不会有类库向全局作用域添加标识符了，但需要通过依赖管理器提供的机制指定引入标识符到具体的作用域中。&lt;/p&gt;

&lt;p&gt;你可能会注意到这些工具并没有什么可以摆脱词法作用域规则的魔法。它们只是运用了作用域规则来强制了标识符不能出现在共享的作用域中，保持标识符私有化，杜绝冲突污染的作用域，以此确保没有意外的作用域冲突。&lt;/p&gt;

&lt;p&gt;因此，你自己也可以写出像模块管理器一样的代码，如果你要这么做。在第五章的模块模式中会有更多信息。&lt;/p&gt;

&lt;h2 id=&quot;作用域函数&quot;&gt;作用域函数&lt;/h2&gt;

&lt;p&gt;我们已经知道可以通过用函数包裹代码的方式有效地隐藏变量和方法。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- insert this&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- and this&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- and this&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;虽然这在技术上可行，但却不是一个好主意。这里有一些小问题。首先我们要声明一个名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;的方法，这意味着叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 的标识符污染了它自己的作用域（这个例子中是全局作用域）。而且我们要明确地通过名字（&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;）来调用这个方法。&lt;/p&gt;

&lt;p&gt;试想一下如果这个方法不需要名字（或者名字不会污染作用域），而且它可以自动执行的话会怎么样呢。&lt;/p&gt;

&lt;p&gt;幸运的是，JavaScript为这个问题提供了解决方案。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- insert this&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- and this&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;让我们看看这都发生了什么。&lt;/p&gt;

&lt;p&gt;首先，要注意的是包装函数表达式是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;(function...&lt;/code&gt;开始的而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;function...&lt;/code&gt;。这个看似微小的细节，实际上有很大的不同。相较于标准的函数声明，这个函数被当做一个函数表达式来对待。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注释:&lt;/strong&gt;一个区别声明和表达式的最简单方法就是”function”单词在语句中的位置。如果”function”在语句最前端，那他就是函数声明。不然就是一个函数表达式。&lt;/p&gt;

&lt;p&gt;我们可以发现函数声明和函数表达式的主要不同在于他们的名字在何处绑定为标识符。&lt;/p&gt;

&lt;p&gt;对比前面的两段代码。第一段中的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;在环绕作用域中绑定。第二段中，&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;不在环绕作用域中绑定，而是在他自己内部的方法中绑定。&lt;/p&gt;

&lt;p&gt;换句话说，&lt;code class=&quot;highlighter-rouge&quot;&gt;(function foo(){ .. })&lt;/code&gt; 是一个表达式意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;标识符 &lt;em&gt;只能&lt;/em&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;的内部被找到，而不能在外部作用域中找到。&lt;/p&gt;

&lt;p&gt;In other words, &lt;code class=&quot;highlighter-rouge&quot;&gt;(function foo(){ .. })&lt;/code&gt; as an expression means the identifier &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; is found &lt;em&gt;only&lt;/em&gt; in the scope where the &lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;。 把&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的名字隐藏在它自己内部意味着它不会无故的污染环绕作用域。&lt;/p&gt;

&lt;h3 id=&quot;匿名-vs-声明的&quot;&gt;匿名 vs. 声明的&lt;/h3&gt;

&lt;p&gt;你可能最熟悉把函数表达式作为一个回调参数了吧，就像：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;I waited 1 second!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这被叫做“匿名函数表达式”，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;function()...&lt;/code&gt;没有他自己的标识符。函数表达式可以是匿名的，但方法声明不能漏掉名字，因为那样会引起JS语法错误。&lt;/p&gt;

&lt;p&gt;匿名函数表达式很简单，很多类库和工具都鼓励使用这种惯用的编码风格。
尽管它们需要考虑几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;匿名函数没有在追踪栈里留下有用的名字，这增大了调试难度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有名字的情况下，当函数需要引用自己（诸如递归）时，就要不幸的用到&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments.callee&lt;/code&gt;这种已经&lt;strong&gt;不推荐&lt;/strong&gt;的引用了。另一个函数需要自我引用的例子就是一个事件处理函数需要在触发之后解除绑定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;匿名函数删掉了有利于代码可读性的名字。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;行内函数表达式&lt;/strong&gt;是强大和有用的————但依然也引出很多问题，为你的函数表达式起个名字就能很好的解决。所以始终给你的函数表达式命名是一个最佳的实践：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeoutHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 瞧，我有一个名字!&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;I waited 1 second!&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;立即执行函数表达式&quot;&gt;立即执行函数表达式&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们为函数加上一对括号使之成为函数表达式，我们可以通过在它后面在加上&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; 使函数执行，就像&lt;code class=&quot;highlighter-rouge&quot;&gt;(function foo(){ .. })()&lt;/code&gt;。第一对括号生成一个函数表达式，第二对括号使函数执行。&lt;/p&gt;

&lt;p&gt;只是一个很普通的模式，几年前在业界就为此有了一个术语：&lt;strong&gt;IIFE&lt;/strong&gt;，代表了&lt;strong&gt;I&lt;/strong&gt;mmediately &lt;strong&gt;I&lt;/strong&gt;nvoked &lt;strong&gt;F&lt;/strong&gt;unction &lt;strong&gt;E&lt;/strong&gt;xpression（立即执行函数表达式）。&lt;/p&gt;

&lt;p&gt;当然，IIFE不一定需要名字，IIFE的通常格式就是用一个匿名函数表达式。虽然不是通常用法，但为IIFE命名也拥有上面所有匿名函数表达式的好处，所以不失为一个好的选择实践。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这与通常的IIFE格式（&lt;code class=&quot;highlighter-rouge&quot;&gt;(function(){ .. }())&lt;/code&gt;）相比有一些小差异。仔细看看有什么不同。第一个格式中，函数表达式被包裹在 &lt;code class=&quot;highlighter-rouge&quot;&gt;( )&lt;/code&gt;中，然后执行括号对在它的外面。第二个格式中，执行括号对被移动到了包裹括号对里面。&lt;/p&gt;

&lt;p&gt;这两种格式在功能上都是相同的。&lt;strong&gt;用哪一种完全出于你的格式喜好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IIFE另一个在实际中更常用的方式就是调用函数，并给他传入参数。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们传入了&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;对象的引用，但我们给参数命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;，从而在文法上相较于非全局引用更清晰，你可以传入在包裹作用域的任何东西，然后为参数来一个恰当的命名。这更是一种文法风格的选择。&lt;/p&gt;

&lt;p&gt;这个模式的另一个应用就是防止因&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;标识符被不正确的重写而引起的意外结果。通过把参数命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;而不传入参数，我们就能确保&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;标识符确实是undefined的值：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// setting a land-mine for other code! avoid!&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Undefined is safe here!&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;还有一种用法就是把函数作为参数传入。这种模式被应用在UMD（Universal Module Definition）项目中。有的人会觉得这样做更清晰和利用理解，尽管它有一些冗长：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;def&lt;/code&gt;函数表达式在代码段的后半部分，被作为一个参数传入定义在代码段前半部分的&lt;code class=&quot;highlighter-rouge&quot;&gt;IIFE&lt;/code&gt;函数。最后，参数&lt;code class=&quot;highlighter-rouge&quot;&gt;def&lt;/code&gt;（函数）被执行，带着传入的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;）。&lt;/p&gt;

&lt;h2 id=&quot;块级作用域&quot;&gt;块级作用域&lt;/h2&gt;

&lt;p&gt;函数是最普通的作用域单元，当然，在广泛传播的JS设计方法中，还有别的作用域单元，运用这些作用域单元，可以让代码变得更加清晰可维护。&lt;/p&gt;

&lt;p&gt;很多JavaScript之外的语言都支持块级作用域，所以其他语言的开发者们对这个概念就有思维定势，而以JavaScript为主的开发者对这个概念可能会有点陌生。&lt;/p&gt;

&lt;p&gt;但就算你一次也没写过块级作用域，你对JavaScript这段代码也肯定很熟悉。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们直接在循环的开头声明了变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;，我们很可能只希望在这个循环中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;，但忽略了这个变量存在于包裹作用域（函数或全局对象）中。&lt;/p&gt;

&lt;p&gt;这就是块级作用域。尽量在使用时就近声明变量。
另一个例子:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们只在if代码中用到了变量&lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;，这让人意识到我们应该在if块中声明&lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;。尽管我们在哪用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;来声明变量都没关系，因为他们都属于包裹作用域。这段代码实际上是一个“假的”块级作用域，应该自我强制不要在作用域的其他地方用到&lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;块级作用域是一个扩展前面提到“最小权限暴露原则”的工具，通过把在函数中隐藏信息变为在代码块中隐藏信息。&lt;/p&gt;

&lt;p&gt;再看看前面的循环例子：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;为什么只在循环中使用的变量&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;会污染整个函数作用域？&lt;/p&gt;

&lt;p&gt;但更重要的是，开发者们喜欢靠自己检查来排查不在他们意图范围内的变量使用，例如在一个错误的地方使用一个未知的变量会抛出一个错误。块级作用域（如果有的话）可以让变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;只在循环内有效，在函数的其他地方使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;会引发错误。这样能确保变量不在其他不好排查的地方重复使用。&lt;/p&gt;

&lt;p&gt;但是，令人伤心的事实是，表面上，JavaScript没有块级作用域场景。&lt;/p&gt;

&lt;p&gt;除非，你更深入一点。&lt;/p&gt;

&lt;h3 id=&quot;with&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们在第二章学过&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;。尽管它是个令人皱眉的结构，但它确实是一个块级作用域的例子，作用域在&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;块中，而不在包裹作用域中。&lt;/p&gt;

&lt;h3 id=&quot;trycatch&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;try/catch&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这是个鲜为人知的事实，在ES3版本的JavaScript中的&lt;code class=&quot;highlighter-rouge&quot;&gt;try/catch&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;块是一个块级作用域。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 强制引起异常的非法操作!&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 起作用了!&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: `err` not found&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如你所见， &lt;code class=&quot;highlighter-rouge&quot;&gt;err&lt;/code&gt;只存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;分句子中，当你在别处引用它时会抛出异常。&lt;/p&gt;

&lt;h3 id=&quot;let&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;目前为止，我们在探索块级作用域的过程中看到了很多怪异的行为。如果只是这些的话，块级作用域对JavaScript开发者就没什么大用了。&lt;/p&gt;

&lt;p&gt;幸运的是，ES6改变了这一切，它引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;关键字，是&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;之外的另一种声明变量的方式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;关键字声明的变量是块级作用域有效的。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;来使变量依附块级作用域多少有些含蓄。当你没有太在意变量属于哪个作用域是可能会引起困惑，用新的块把它们包裹起来是一个进化你新代码的好习惯。&lt;/p&gt;

&lt;p&gt;为块级作用域创建明确的块可以打消这些担忧:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- explicit block&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们只需简单创建一对大括号来绑定&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;并且这是语法可行的。在这个例子中，我们在if分句中创造了一个明确的块，这样做既简单有不会影响if分句的语义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注释:&lt;/strong&gt; 另一种指定块级作用域的方法，见附录B。&lt;/p&gt;

&lt;p&gt;在第四章中，我们要讨论提升，在声明所处的作用域中，处处可以得到它。&lt;/p&gt;

&lt;p&gt;但是，用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;的声明不会提升到整个块中。这种声明直到执行到声明语句时才会被认为是存在的。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError!&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h4&gt;

&lt;p&gt;块级作用域有用的另一个原因是对于闭包和垃圾回收的。我们只在这里简要提及，闭包机制我们会在第五章详细介绍。&lt;/p&gt;

&lt;p&gt;且看:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// do something interesting&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someReallyBigData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someReallyBigData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my_button&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;button clicked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*capturingPhase=*/&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;click&lt;/code&gt;函数的点击处理回调完全不需要&lt;code class=&quot;highlighter-rouge&quot;&gt;someReallyBigData&lt;/code&gt;变量。这就是说，理论上&lt;code class=&quot;highlighter-rouge&quot;&gt;process(..)&lt;/code&gt;执行之后，这个占用很多内存的数据结构就可以被当做垃圾回收了。但是，JS引擎似乎（取决于引擎具体实现）还保存着这个数据。&lt;/p&gt;

&lt;p&gt;块级作用域可以解决这个问题，只需告诉引擎 &lt;code class=&quot;highlighter-rouge&quot;&gt;someReallyBigData&lt;/code&gt;不需要再保存了：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// do something interesting&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 任何在块中声明的东西之后就可以滚了!&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someReallyBigData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someReallyBigData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my_button&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;button clicked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*capturingPhase=*/&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为变量声明明确的块用来本地绑定是一个强大的工具，足以加入你的代码工具箱了。&lt;/p&gt;

&lt;h4 id=&quot;let-循环&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; 循环&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;闪耀的另一个场景就是在前面讨论过的for循环例子中。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在for循环头部的&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;不仅把&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;绑定到了循环体中，事实上，它还在每次循环迭代中重建了变量&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;，以确保&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;被重新赋予前面迭代结果的值。&lt;/p&gt;

&lt;p&gt;这是另一种每次迭代绑定行为的例子：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// re-bound for each iteration!&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每次迭代绑定为什么有趣的原因会在第五章讨论闭包时水落石出。&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;声明依附于任意块而非闭合函数作用域，所以不难理解用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;声明的隐藏代码需要依赖函数作用域，并且在重构代码时用 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;代替 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;要多加留意。&lt;/p&gt;

&lt;p&gt;且看:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很容易就能把这段代码重构为:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是，针对块级作用域变量这么做是就要多加小心了：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 移动时别忘了把`bar`也带上!&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;附录B中可以看到一种代替（更明确）的块级作用域代码风格，针对这种情况更健壮，更容易维护和重构。&lt;/p&gt;

&lt;h3 id=&quot;const&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;的补充，ES6引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;关键字，它也能创建块级作用域变量，但它的值是固定的。任何试图改变&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;值得操作都会引起系统报错。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 存在于if的块级作用域中&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 没问题!&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 报错!&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;函数是JavaScript中最普通的作用域单元。在函数中声明的变量和函数会被对外“隐藏”起来，这是一种很好的软件设计原则。&lt;/p&gt;

&lt;p&gt;但函数不是唯一的作用域单元。块级作用域就是用块（通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;对）包裹代码，而不单单是包裹函数。&lt;/p&gt;

&lt;p&gt;从ES3开始，&lt;code class=&quot;highlighter-rouge&quot;&gt;try/catch&lt;/code&gt;结构的&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;就形成了一个块级作用域。&lt;/p&gt;

&lt;p&gt;在ES6中，&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;关键字（&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;关键字的表亲），就被引入用来在任何代码块中声明变量。 &lt;code class=&quot;highlighter-rouge&quot;&gt;if (..) { let a = 2; }&lt;/code&gt;声明了一个变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，它实际上劫持了&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;块并且把自己依附在上面。&lt;/p&gt;

&lt;p&gt;块级作用域不应该取代函数作域。两种功能应该并存，开发者们应该用好函数作用域和块级作用域在各自适合的场景去生产更好，更可读可维护的代码。&lt;/p&gt;</content><author><name>Laolizi</name><email>dllglishaoi@gmail.com</email></author><category term="JavaScript" /><summary type="html">你不知道的JS:作用域和闭包 第三章: 函数 vs. 块级作用域</summary></entry></feed>